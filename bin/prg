#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/ruby-progress'
require 'fileutils'
require 'optparse'
require 'json'
require 'English'

# Unified progress indicator CLI
module PrgCLI
  def self.run
    if ARGV.empty?
      show_help
      exit 1
    end

      # Early scan: detect --ends flag and validate its argument before dispatching
      if (i = ARGV.index('--ends')) && ARGV[i + 1]
        ends_val = ARGV[i + 1]
        unless RubyProgress::Utils.ends_valid?(ends_val)
          puts 'Invalid --ends value: must contain an even number of characters'
          exit 1
        end
      end

      subcommand = ARGV.shift.downcase

    case subcommand
    when 'ripple'
      RippleCLI.run
    when 'worm'
      WormCLI.run
    when 'twirl'
      TwirlCLI.run
    when 'fill'
      RubyProgress::FillCLI.run
    when '--list-styles'
      list_styles
      exit
    when '--show-styles'
      show_styles
      exit
    when '--stop-all'
      success = stop_all_processes
      exit(success ? 0 : 1)
    when '-v', '--version'
      puts "prg version #{RubyProgress::VERSION}"
      puts "  ripple - Text ripple animation with color effects (v#{RubyProgress::RIPPLE_VERSION})"
      puts "  worm   - Unicode wave animation with customizable styles (v#{RubyProgress::WORM_VERSION})"
      puts "  twirl  - Spinner animation with various indicator styles (v#{RubyProgress::TWIRL_VERSION})"
      puts "  fill   - Determinate progress bar with customizable styles (v#{RubyProgress::FILL_VERSION})"
      exit
    when '-h', '--help', 'help'
      show_help
      exit
    else
      puts "Error: Unknown subcommand '#{subcommand}'"
      puts "Run 'prg --help' for usage information."
      exit 1
    end
  end

  def self.show_help
    puts <<~HELP
      prg - Unified Ruby Progress Indicators

      USAGE:
          prg <subcommand> [options]

      SUBCOMMANDS:
          ripple    Text ripple animation with color effects
          worm      Unicode wave animation with customizable dot styles
          twirl     Spinner-based animation with various indicator styles
          fill      Determinate progress bar with customizable fill styles

      GLOBAL OPTIONS:
          -v, --version    Show version information
          -h, --help       Show this help message
          --list-styles    List all available styles for all subcommands
          --show-styles    Show visual previews of all styles for all subcommands
          --stop-all       Stop all prg processes

      COMMON OPTIONS (available for all subcommands):
          --ends CHARS     Start/end characters (even number split in half)
          --speed SPEED    Animation speed (fast/medium/slow)
          --message TEXT   Message to display with animation
          --checkmark      Show checkmarks for success/failure
          --command CMD    Execute command during animation

      EXAMPLES:
          prg ripple "Loading..." --style rainbow --speed fast --ends "[]"
          prg worm --message "Processing" --style blocks --checkmark --ends "()"
          prg twirl --message "Spinning" --style dots --checkmark --ends "<<>>"
          prg ripple --command "sleep 3" --success "Done!" --checkmark --ends "{}"

      Run 'prg <subcommand> --help' for specific subcommand options.
    HELP
  end

  # Detach the current process into a background daemon so the calling shell
  # doesn't track it as a job (prevents 'job ... has ended' notifications).
  # Intentionally keeps stdio open so the daemon can print a final message.
  def self.daemonize
    return if ENV['PRG_NO_DAEMONIZE'] == '1'

    pid = fork
    if pid
      # Parent exits immediately; child continues
      exit 0
    end

    # Become session leader and detach from controlling terminal
    Process.setsid

    # Second fork to avoid reacquiring a controlling terminal
    pid2 = fork
    exit 0 if pid2

    # Do not chdir or close stdio: we want to be able to emit completion output
  end

  def self.list_styles
    puts '== ripple styles'
    puts 'rainbow, inverse, caps, normal'
    puts ''

    puts '== worm styles'
    worm_styles = RubyProgress::Worm::RIPPLE_STYLES
    style_names = worm_styles.keys.reject { |name| name == 'cirlces_small' }
    puts style_names.join(', ')
    puts ''

    puts '== twirl styles'
    twirl_names = RubyProgress::INDICATORS.keys.map(&:to_s)
    puts twirl_names.join(', ')
    puts ''
    puts '== fill =='
    if defined?(RubyProgress::Fill::FILL_STYLES)
      puts RubyProgress::Fill::FILL_STYLES.keys.map(&:to_s).join(', ')
    else
      puts 'blocks, classic, dots, ascii, bars, squares, circles, arrows, stars'
    end
  end

  def self.show_styles
    show_ripple_styles
    show_worm_styles
    show_twirl_styles
    show_fill_styles
  end

  def self.show_ripple_styles
    puts '== ripple styles (visual effects for text)'

    # Create sample text for ripple previews
    sample_text = 'Progress'

    # Rainbow preview - show with actual rainbow colors
    rainbow_preview = sample_text.chars.map.with_index do |char, i|
      colors = [31, 32, 33, 34, 35, 36] # red, green, yellow, blue, magenta, cyan
      "\e[#{colors[i % colors.length]}m#{char}\e[0m"
    end.join
    puts "rainbow    - #{rainbow_preview}"

    # Inverse preview - show with actual inverse background
    inverse_preview = "\e[7m#{sample_text}\e[0m"
    puts "inverse    - #{inverse_preview}"

    # Caps preview
    caps_preview = sample_text.upcase
    puts "caps       - #{caps_preview}"

    # Normal preview
    puts "normal     - #{sample_text}"

    # Show ripple effect preview with highlighted character in middle
    puts ''
    puts 'Ripple effect preview (character 4 highlighted):'
    ripple_demo = sample_text.chars.map.with_index do |char, i|
      if i == 3 # highlight the 'g' in Progress
        "\e[7m#{char}\e[0m" # inverse highlight
      else
        char
      end
    end.join
    puts "normal     - #{ripple_demo}"

    inverse_ripple_demo = sample_text.chars.map.with_index do |char, i|
      if i == 3 # highlight the 'g' in Progress
        "\e[0m#{char}\e[7m" # normal char in inverse text
      else
        "\e[7m#{char}\e[0m" # inverse char
      end
    end.join
    puts "inverse    - \e[7m#{inverse_ripple_demo}\e[0m"
    puts ''
  end

  def self.show_worm_styles
    puts '== worm styles (wave animation patterns)'
    # Load worm styles for preview
    worm_styles = RubyProgress::Worm::RIPPLE_STYLES
    worm_styles.each do |name, chars|
      next if name == 'cirlces_small' # skip typo version

      baseline = chars[:baseline]
      midline = chars[:midline]
      peak = chars[:peak]
      preview = "#{baseline}#{baseline}#{midline}#{peak}#{midline}#{baseline}#{baseline}"
      puts "#{name.ljust(10)} - #{preview}"
    end
    puts ''
  end

  def self.show_twirl_styles
    puts '== twirl styles (spinner characters)'
    RubyProgress::INDICATORS.each do |name, frames|
      preview = frames.join(' ')
      puts "#{name.to_s.ljust(12)} - #{preview}"
    end
  end

  def self.show_fill_styles
    puts '== fill =='
    if defined?(RubyProgress::Fill::FILL_STYLES)
      RubyProgress::Fill::FILL_STYLES.each do |name, style|
        puts "#{name.to_s.ljust(10)} - #{style[:empty]} #{style[:full]}"
      end
    else
      puts 'blocks     - â–± â–°'
      puts 'classic    - - ='
      puts 'dots       - Â· â—'
    end
  end

  def self.stop_all_processes
    current_pid = Process.pid

    # Get list of prg processes excluding current process
    prg_pids = `pgrep -f "ruby.*bin/prg"`.split.map(&:to_i).reject { |pid| pid == current_pid }

    return false if prg_pids.empty?

    # First try TERM signal
    prg_pids.each do |pid|
      Process.kill('TERM', pid)
    rescue StandardError
      # Ignore errors if process already terminated
    end

    # Give processes a moment to terminate gracefully
    sleep 0.5

    # Check which processes are still running and force kill them
    still_running = `pgrep -f "ruby.*bin/prg"`.split.map(&:to_i).reject { |pid| pid == current_pid }
    unless still_running.empty?
      still_running.each do |pid|
        Process.kill('KILL', pid)
      rescue StandardError
        # Ignore errors if process already terminated
      end
    end

    true
  end

  def self.stop_subcommand_processes(subcommand)
    current_pid = Process.pid

    # Get list of subcommand processes excluding current process
    subcommand_pids = `pgrep -f "ruby.*bin/prg #{subcommand}"`.split.map(&:to_i).reject { |pid| pid == current_pid }

    return false if subcommand_pids.empty?

    # First try TERM signal
    subcommand_pids.each do |pid|
      Process.kill('TERM', pid)
    rescue StandardError
      # Ignore errors if process already terminated
    end

    # Give processes a moment to terminate gracefully
    sleep 0.5

    # Check which processes are still running and force kill them
    still_running = `pgrep -f "ruby.*bin/prg #{subcommand}"`.split.map(&:to_i).reject { |pid| pid == current_pid }
    unless still_running.empty?
      still_running.each do |pid|
        Process.kill('KILL', pid)
      rescue StandardError
        # Ignore errors if process already terminated
      end
    end

    true
  end
end

# Enhanced Ripple CLI with unified flags
module RippleCLI
  def self.run
    trap('INT') do
      RubyProgress::Utils.show_cursor
      exit
    end

    options = {
      speed: :medium,
      direction: :bidirectional,
      styles: [],
      caps: false,
      command: nil,
      success_message: nil,
      fail_message: nil,
      complete_checkmark: false,
      output: :error,
      message: nil # For unified interface
    }

    begin
      OptionParser.new do |opts|
        opts.banner = 'Usage: prg ripple [options] [STRING]'
        opts.separator ''
        opts.separator 'Animation Options:'

        opts.on('-s', '--speed SPEED', 'Animation speed (fast/medium/slow or f/m/s)') do |s|
          options[:speed] = case s.downcase
                            when /^f/ then :fast
                            when /^m/ then :medium
                            when /^s/ then :slow
                            else :medium
                            end
        end

        opts.on('-m', '--message MESSAGE', 'Message to display (alternative to positional argument)') do |msg|
          options[:message] = msg
        end

        opts.on('--style STYLES', 'Animation styles (rainbow, inverse, caps - can be comma-separated)') do |styles|
          options[:styles] = styles.split(',').map(&:strip).map(&:to_sym)
        end

        opts.on('-d', '--direction DIRECTION', 'Animation direction (forward/bidirectional or f/b)') do |f|
          options[:format] = f =~ /^f/i ? :forward_only : :bidirectional
        end

        opts.on('--ends CHARS', 'Start/end characters (even number of chars, split in half)') do |chars|
          options[:ends] = chars
        end

        opts.separator ''
        opts.separator 'Command Execution:'

        opts.on('-c', '--command COMMAND', 'Run command during animation (optional)') do |command|
          options[:command] = command
        end

        opts.on('--success MESSAGE', 'Success message to display') do |msg|
          options[:success_message] = msg
        end

        opts.on('--error MESSAGE', 'Error message to display') do |msg|
          options[:fail_message] = msg
        end

        opts.on('--checkmark', 'Show checkmarks (âœ… success, ðŸ›‘ failure)') do
          options[:complete_checkmark] = true
        end

        opts.on('--stdout', 'Output captured command result to STDOUT') do
          options[:output] = :stdout
        end

        opts.on('--quiet', 'Suppress all output') do
          options[:output] = :quiet
        end

        opts.separator ''
        opts.separator 'Daemon Mode:'

        opts.on('--daemon', 'Run in background daemon mode') do
          options[:daemon] = true
        end

        opts.on('--pid-file FILE', 'Write process ID to file (default: /tmp/ruby-progress/progress.pid)') do |file|
          options[:pid_file] = file
        end

        opts.on('--stop', 'Stop daemon (uses default PID file unless --pid-file specified)') do
          options[:stop] = true
        end

        opts.on('--status', 'Show daemon status (running/not running)') do
          options[:status] = true
        end

        opts.on('--stop-success MESSAGE', 'When stopping, show this success message') do |msg|
          options[:stop_success] = msg
        end
        opts.on('--stop-error MESSAGE', 'When stopping, show this error message') do |msg|
          options[:stop_error] = msg
        end
        opts.on('--stop-checkmark', 'When stopping, include a success/error checkmark') do
          options[:stop_checkmark] = true
        end

        opts.separator ''
        opts.separator 'Daemon notes:'
        opts.separator '  - Do not append &; prg detaches itself and returns immediately.'
        opts.separator '  - Use --status/--stop with optional --pid-file to control it.'

        opts.separator ''
        opts.separator 'General:'

        opts.on('--show-styles', 'Show available ripple styles with visual previews') do
          PrgCLI.show_ripple_styles
          exit
        end

        opts.on('--stop-all', 'Stop all prg ripple processes') do
          success = PrgCLI.stop_subcommand_processes('ripple')
          exit(success ? 0 : 1)
        end

        opts.on('-v', '--version', 'Show version') do
          puts "Ripple version #{RubyProgress::VERSION}"
          exit
        end

        opts.on('-h', '--help', 'Show this help') do
          puts opts
          exit
        end
      end.parse!
    rescue OptionParser::InvalidOption => e
      puts "Invalid option: #{e.args.first}"
      puts ''
      puts 'Usage: prg ripple [options] [STRING]'
      puts "Run 'prg ripple --help' for more information."
      exit 1
    end

    # Daemon/status/stop handling (process these without requiring text)
    if options[:status]
      pid_file = options[:pid_file] || RubyProgress::Daemon.default_pid_file
      RubyProgress::Daemon.show_status(pid_file)
      exit
    elsif options[:stop]
      pid_file = options[:pid_file] || RubyProgress::Daemon.default_pid_file
      stop_msg = options[:stop_error] || options[:stop_success]
      is_error = !options[:stop_error].nil?
      RubyProgress::Daemon.stop_daemon_by_pid_file(
        pid_file,
        message: stop_msg,
        checkmark: options[:stop_checkmark],
        error: is_error
      )
      exit
    elsif options[:daemon]
      # For daemon mode, detach so shell has no tracked job
      PrgCLI.daemonize

      # For daemon mode, default message if none provided
      text = options[:message] || ARGV.join(' ')
      text = 'Processing' if text.nil? || text.empty?
      run_daemon_mode(text, options)
    else
      # Non-daemon path requires text
      text = options[:message] || ARGV.join(' ')
      if text.empty?
        puts 'Error: Please provide text to animate via argument or --message flag'
        puts "Example: prg ripple 'Loading...' or prg ripple --message 'Loading...'"
        exit 1
      end

      # Convert styles array to individual flags for backward compatibility
      options[:rainbow] = options[:styles].include?(:rainbow)
      options[:inverse] = options[:styles].include?(:inverse)
      options[:caps] = options[:styles].include?(:caps)

      if options[:command]
        run_with_command(text, options)
      else
        run_indefinitely(text, options)
      end
    end
  end

  def self.run_with_command(text, options)
    captured_output = nil
    RubyProgress::Ripple.progress(text, options) do
      captured_output = `#{options[:command]} 2>&1`
    end

    success = $CHILD_STATUS.success?

    puts captured_output if options[:output] == :stdout
    if options[:success_message] || options[:complete_checkmark]
      message = success ? options[:success_message] : options[:fail_message] || options[:success_message]
      RubyProgress::Ripple.complete(text, message, options[:complete_checkmark], success)
    end
    exit success ? 0 : 1
  end

  def self.run_indefinitely(text, options)
    rippler = RubyProgress::Ripple.new(text, options)
    RubyProgress::Utils.hide_cursor
    begin
      loop { rippler.advance }
    ensure
      RubyProgress::Utils.show_cursor
      RubyProgress::Ripple.complete(text, options[:success_message], options[:complete_checkmark], true)
    end
  end

  def self.run_daemon_mode(text, options)
    pid_file = options[:pid_file] || RubyProgress::Daemon.default_pid_file
    FileUtils.mkdir_p(File.dirname(pid_file))
    File.write(pid_file, Process.pid.to_s)

    begin
      # For Ripple, re-use the existing animation loop via a simple loop
      RubyProgress::Utils.hide_cursor
      rippler = RubyProgress::Ripple.new(text, options)
      stop_requested = false

      Signal.trap('INT') { stop_requested = true }
      Signal.trap('USR1') { stop_requested = true }
      Signal.trap('TERM') { stop_requested = true }
      Signal.trap('HUP')  { stop_requested = true }

      rippler.advance until stop_requested
    ensure
      RubyProgress::Utils.clear_line
      RubyProgress::Utils.show_cursor

      # If a control message file exists, output its message with optional checkmark
      cmf = RubyProgress::Daemon.control_message_file(pid_file)
      if File.exist?(cmf)
        begin
          data = JSON.parse(File.read(cmf))
          message = data['message']
          check = data.key?('checkmark') ? !!data['checkmark'] : false
          success_val = data.key?('success') ? !!data['success'] : true
          if message
            RubyProgress::Utils.display_completion(
              message,
              success: success_val,
              show_checkmark: check,
              output_stream: :stdout
            )
          end
        rescue StandardError
          # ignore
        ensure
          begin
            File.delete(cmf)
          rescue StandardError
            nil
          end
        end
      end

      FileUtils.rm_f(pid_file)
    end
  end
end

# Enhanced Worm CLI with unified flags
module WormCLI
  def self.run
    options = parse_cli_options

    if options[:status]
      pid_file = resolve_pid_file(options, :status_name)
      RubyProgress::Daemon.show_status(pid_file)
      exit
    elsif options[:stop]
      pid_file = resolve_pid_file(options, :stop_name)
      stop_msg = options[:stop_error] || options[:stop_success]
      is_error = !options[:stop_error].nil?
      RubyProgress::Daemon.stop_daemon_by_pid_file(
        pid_file,
        message: stop_msg,
        checkmark: options[:stop_checkmark],
        error: is_error
      )
      exit
    elsif options[:daemon]
      # Detach before starting daemon logic so there's no tracked shell job
      PrgCLI.daemonize
      run_daemon_mode(options)
    else
      progress = RubyProgress::Worm.new(options)

      if options[:command]
        progress.run_with_command
      else
        progress.run_indefinitely
      end
    end
  end

  def self.run_daemon_mode(options)
    # Use daemon name or default PID file if none specified
    pid_file = resolve_pid_file(options, :daemon_name)

    # Ensure directory exists
    FileUtils.mkdir_p(File.dirname(pid_file))

    # Write PID file
    File.write(pid_file, Process.pid.to_s)

    progress = RubyProgress::Worm.new(options)

    begin
      progress.run_daemon_mode(
        success_message: options[:success],
        show_checkmark: options[:checkmark],
        control_message_file: RubyProgress::Daemon.control_message_file(pid_file)
      )
    ensure
      # Clean up PID file
      FileUtils.rm_f(pid_file)
    end
  end

  def self.resolve_pid_file(options, name_key)
    return options[:pid_file] if options[:pid_file]

    if options[name_key]
      "/tmp/ruby-progress/#{options[name_key]}.pid"
    else
      RubyProgress::Daemon.default_pid_file
    end
  end

  def self.parse_cli_options
    options = {}

    OptionParser.new do |opts|
      opts.banner = 'Usage: prg worm [options]'
      opts.separator ''
      opts.separator 'Animation Options:'

      opts.on('-s', '--speed SPEED', 'Animation speed (1-10, fast/medium/slow, or f/m/s)') do |speed|
        options[:speed] = speed
      end

      opts.on('-m', '--message MESSAGE', 'Message to display before animation') do |message|
        options[:message] = message
      end

      opts.on('-l', '--length LENGTH', Integer, 'Number of dots to display') do |length|
        options[:length] = length
      end

      opts.on('--style STYLE', 'Animation style (circles/blocks/geometric, c/b/g, or custom=abc)') do |style|
        options[:style] = style
      end

      opts.on('-d', '--direction DIRECTION', 'Animation direction (forward/bidirectional or f/b)') do |direction|
        options[:direction] = direction =~ /^f/i ? :forward_only : :bidirectional
      end

      opts.on('--ends CHARS', 'Start/end characters (even number of chars, split in half)') do |chars|
        options[:ends] = chars
      end

      opts.separator ''
      opts.separator 'Command Execution:'

      opts.on('-c', '--command COMMAND', 'Command to run (optional - runs indefinitely without)') do |command|
        options[:command] = command
      end

      opts.on('--success MESSAGE', 'Success message to display') do |text|
        options[:success] = text
      end

      opts.on('--error MESSAGE', 'Error message to display') do |text|
        options[:error] = text
      end

      opts.on('--checkmark', 'Show checkmarks (âœ… success, ðŸ›‘ failure)') do
        options[:checkmark] = true
      end

      opts.on('--stdout', 'Output captured command result to STDOUT') do
        options[:stdout] = true
      end

      opts.separator ''
      opts.separator 'Daemon Mode:'

      opts.on('--daemon', 'Run in background daemon mode') do
        options[:daemon] = true
      end

      opts.on('--daemon-as NAME', 'Run in daemon mode with custom name (creates /tmp/ruby-progress/NAME.pid)') do |name|
        options[:daemon] = true
        options[:daemon_name] = name
      end

      opts.on('--pid-file FILE', 'Write process ID to file (default: /tmp/ruby-progress/progress.pid)') do |file|
        options[:pid_file] = file
      end

      opts.on('--stop', 'Stop daemon (uses default PID file unless --pid-file specified)') do
        options[:stop] = true
      end
      opts.on('--stop-id NAME', 'Stop daemon by name (automatically implies --stop)') do |name|
        options[:stop] = true
        options[:stop_name] = name
      end
      opts.on('--status', 'Show daemon status (uses default PID file unless --pid-file specified)') do
        options[:status] = true
      end
      opts.on('--status-id NAME', 'Show daemon status by name') do |name|
        options[:status] = true
        options[:status_name] = name
      end
      opts.on('--stop-success MESSAGE', 'Stop daemon with success message (automatically implies --stop)') do |msg|
        options[:stop] = true
        options[:stop_success] = msg
      end
      opts.on('--stop-error MESSAGE', 'Stop daemon with error message (automatically implies --stop)') do |msg|
        options[:stop] = true
        options[:stop_error] = msg
      end
      opts.on('--stop-checkmark', 'When stopping, include a success checkmark') { options[:stop_checkmark] = true }

      opts.on('--stop-all', 'Stop all prg worm processes') do
        success = PrgCLI.stop_subcommand_processes('worm')
        exit(success ? 0 : 1)
      end

      opts.on('--stop-pid FILE', 'Stop daemon by reading PID from file (deprecated: use --stop [--pid-file])') do |file|
        RubyProgress::Daemon.stop_daemon_by_pid_file(file)
        exit
      end

      opts.separator ''
      opts.separator 'Daemon notes:'
      opts.separator '  - Do not append &; prg detaches itself and returns immediately.'
      opts.separator '  - Use --daemon-as NAME for named daemons, or --stop-id/--status-id for named control.'

      opts.separator ''
      opts.separator 'General:'

      opts.on('--show-styles', 'Show available worm styles with visual previews') do
        PrgCLI.show_worm_styles
        exit
      end

      opts.on('--stop-all', 'Stop all prg worm processes') do
        success = PrgCLI.stop_subcommand_processes('worm')
        exit(success ? 0 : 1)
      end

      opts.on('-v', '--version', 'Show version') do
        puts "Worm version #{RubyProgress::VERSION}"
        exit
      end

      opts.on('-h', '--help', 'Show this help') do
        puts opts
        exit
      end
    end.parse!

    # Validate --ends (fast-fail if odd-length)
    if options[:ends] && !RubyProgress::Utils.ends_valid?(options[:ends])
      puts 'Invalid --ends value: must contain an even number of characters'
      exit 1
    end

    # Validate --ends for even-length input (if provided)
    if options[:ends] && !RubyProgress::Utils.ends_valid?(options[:ends])
      puts 'Invalid --ends value: must contain an even number of characters'
      exit 1
    end

    # Validate --ends for even-length input (if provided)
    if options[:ends] && !RubyProgress::Utils.ends_valid?(options[:ends])
      puts 'Invalid --ends value: must contain an even number of characters'
      exit 1
    end

    options
  rescue OptionParser::InvalidOption => e
    puts "Invalid option: #{e.args.first}"
    puts ''
    puts 'Usage: prg worm [options]'
    puts "Run 'prg worm --help' for more information."
    exit 1
  end
end

# Twirl CLI - spinner-based progress indicator
module TwirlCLI
  def self.run
    options = parse_cli_options

    if options[:status]
      pid_file = resolve_pid_file(options, :status_name)
      RubyProgress::Daemon.show_status(pid_file)
      exit
    elsif options[:stop]
      pid_file = resolve_pid_file(options, :stop_name)
      stop_msg = options[:stop_error] || options[:stop_success]
      is_error = !options[:stop_error].nil?
      RubyProgress::Daemon.stop_daemon_by_pid_file(
        pid_file,
        message: stop_msg,
        checkmark: options[:stop_checkmark],
        error: is_error
      )
      exit
    elsif options[:daemon]
      PrgCLI.daemonize
      run_daemon_mode(options)
    elsif options[:command]
      run_with_command(options)
    else
      run_indefinitely(options)
    end
  end

  def self.run_with_command(options)
    message = options[:message]
    captured_output = nil

    spinner = TwirlSpinner.new(message, options)
    success = false

    begin
      RubyProgress::Utils.hide_cursor
      spinner_thread = Thread.new { loop { spinner.animate } }

      captured_output = `#{options[:command]} 2>&1`
      success = $CHILD_STATUS.success?

      spinner_thread.kill
      RubyProgress::Utils.clear_line
    ensure
      RubyProgress::Utils.show_cursor
    end

    puts captured_output if options[:stdout]

    if options[:success] || options[:error] || options[:checkmark]
      final_msg = success ? options[:success] : options[:error]
      final_msg ||= success ? 'Success' : 'Failed'

      RubyProgress::Utils.display_completion(
        final_msg,
        success: success,
        show_checkmark: options[:checkmark]
      )
    end

    exit success ? 0 : 1
  end

  def self.run_indefinitely(options)
    message = options[:message]
    spinner = TwirlSpinner.new(message, options)

    begin
      RubyProgress::Utils.hide_cursor
      loop { spinner.animate }
    ensure
      RubyProgress::Utils.show_cursor
      if options[:success] || options[:checkmark]
        RubyProgress::Utils.display_completion(
          options[:success] || 'Complete',
          success: true,
          show_checkmark: options[:checkmark]
        )
      end
    end
  end

  def self.run_daemon_mode(options)
    pid_file = resolve_pid_file(options, :daemon_name)
    FileUtils.mkdir_p(File.dirname(pid_file))
    File.write(pid_file, Process.pid.to_s)

    message = options[:message]
    spinner = TwirlSpinner.new(message, options)
    stop_requested = false

    Signal.trap('INT') { stop_requested = true }
    Signal.trap('USR1') { stop_requested = true }
    Signal.trap('TERM') { stop_requested = true }
    Signal.trap('HUP') { stop_requested = true }

    begin
      RubyProgress::Utils.hide_cursor
      spinner.animate until stop_requested
    ensure
      RubyProgress::Utils.clear_line
      RubyProgress::Utils.show_cursor

      # Check for control message
      cmf = RubyProgress::Daemon.control_message_file(pid_file)
      if File.exist?(cmf)
        begin
          data = JSON.parse(File.read(cmf))
          message = data['message']
          check = data.key?('checkmark') ? data['checkmark'] : false
          success_val = data.key?('success') ? data['success'] : true
          if message
            RubyProgress::Utils.display_completion(
              message,
              success: success_val,
              show_checkmark: check,
              output_stream: :stdout
            )
          end
        rescue StandardError
          # ignore
        ensure
          begin
            File.delete(cmf)
          rescue StandardError
            nil
          end
        end
      end

      FileUtils.rm_f(pid_file)
    end
  end

  def self.resolve_pid_file(options, name_key)
    return options[:pid_file] if options[:pid_file]

    if options[name_key]
      "/tmp/ruby-progress/#{options[name_key]}.pid"
    else
      RubyProgress::Daemon.default_pid_file
    end
  end

  def self.parse_cli_options
    options = {}

    OptionParser.new do |opts|
      opts.banner = 'Usage: prg twirl [options]'
      opts.separator ''
      opts.separator 'Animation Options:'

      opts.on('-s', '--speed SPEED', 'Animation speed (1-10, fast/medium/slow, or f/m/s)') do |speed|
        options[:speed] = speed
      end

      opts.on('-m', '--message MESSAGE', 'Message to display before spinner') do |message|
        options[:message] = message
      end

      opts.on('--style STYLE', 'Spinner style (see --show-styles for options)') do |style|
        options[:style] = style
      end

      opts.on('--ends CHARS', 'Start/end characters (even number of chars, split in half)') do |chars|
        options[:ends] = chars
      end

      opts.separator ''
      opts.separator 'Command Execution:'

      opts.on('-c', '--command COMMAND', 'Command to run (optional - runs indefinitely without)') do |command|
        options[:command] = command
      end

      opts.on('--success MESSAGE', 'Success message to display') do |text|
        options[:success] = text
      end

      opts.on('--error MESSAGE', 'Error message to display') do |text|
        options[:error] = text
      end

      opts.on('--checkmark', 'Show checkmarks (âœ… success, ðŸ›‘ failure)') do
        options[:checkmark] = true
      end

      opts.on('--stdout', 'Output captured command result to STDOUT') do
        options[:stdout] = true
      end

      opts.separator ''
      opts.separator 'Daemon Mode:'

      opts.on('--daemon', 'Run in background daemon mode') do
        options[:daemon] = true
      end

      opts.on('--daemon-as NAME', 'Run in daemon mode with custom name (creates /tmp/ruby-progress/NAME.pid)') do |name|
        options[:daemon] = true
        options[:daemon_name] = name
      end

      opts.on('--pid-file FILE', 'Write process ID to file (default: /tmp/ruby-progress/progress.pid)') do |file|
        options[:pid_file] = file
      end

      opts.on('--stop', 'Stop daemon (uses default PID file unless --pid-file specified)') do
        options[:stop] = true
      end
      opts.on('--stop-id NAME', 'Stop daemon by name (automatically implies --stop)') do |name|
        options[:stop] = true
        options[:stop_name] = name
      end
      opts.on('--status', 'Show daemon status (uses default PID file unless --pid-file specified)') do
        options[:status] = true
      end
      opts.on('--status-id NAME', 'Show daemon status by name') do |name|
        options[:status] = true
        options[:status_name] = name
      end
      opts.on('--stop-success MESSAGE', 'Stop daemon with success message (automatically implies --stop)') do |msg|
        options[:stop] = true
        options[:stop_success] = msg
      end
      opts.on('--stop-error MESSAGE', 'Stop daemon with error message (automatically implies --stop)') do |msg|
        options[:stop] = true
        options[:stop_error] = msg
      end
      opts.on('--stop-checkmark', 'When stopping, include a success checkmark') { options[:stop_checkmark] = true }

      opts.separator ''
      opts.separator 'Daemon notes:'
      opts.separator '  - Do not append &; prg detaches itself and returns immediately.'
      opts.separator '  - Use --daemon-as NAME for named daemons, or --stop-id/--status-id for named control.'

      opts.separator ''
      opts.separator 'General:'

      opts.on('--show-styles', 'Show available twirl styles with visual previews') do
        PrgCLI.show_twirl_styles
        exit
      end

      opts.on('--stop-all', 'Stop all prg twirl processes') do
        success = PrgCLI.stop_subcommand_processes('twirl')
        exit(success ? 0 : 1)
      end

      opts.on('-v', '--version', 'Show version') do
        puts "Twirl version #{RubyProgress::VERSION}"
        exit
      end

      opts.on('-h', '--help', 'Show this help') do
        puts opts
        exit
      end
    end.parse!

    options
  rescue OptionParser::InvalidOption => e
    puts "Invalid option: #{e.args.first}"
    puts ''
    puts 'Usage: prg twirl [options]'
    puts "Run 'prg twirl --help' for more information."
    exit 1
  end
end

# Simple spinner class for Twirl
class TwirlSpinner
  def initialize(message, options = {})
    @message = message
    @style = parse_style(options[:style] || 'dots')
    @speed = parse_speed(options[:speed] || 'medium')
    @frames = RubyProgress::INDICATORS[@style] || RubyProgress::INDICATORS[:dots]
    @start_chars, @end_chars = RubyProgress::Utils.parse_ends(options[:ends])
    @index = 0
  end

  def animate
    if @message && !@message.empty?
      $stderr.print "\r\e[2K#{@start_chars}#{@message} #{@frames[@index]}#{@end_chars}"
    else
      $stderr.print "\r\e[2K#{@start_chars}#{@frames[@index]}#{@end_chars}"
    end
    $stderr.flush
    @index = (@index + 1) % @frames.length
    sleep @speed
  end

  private

  def parse_style(style_input)
    return :dots unless style_input && !style_input.to_s.strip.empty?

    style_lower = style_input.to_s.downcase.strip

    # First, try exact match (convert string keys to symbols for comparison)
    indicator_keys = RubyProgress::INDICATORS.keys.map(&:to_s)
    return style_lower.to_sym if indicator_keys.include?(style_lower)

    # Then try prefix matching - keys that start with the input
    prefix_matches = indicator_keys.select do |key|
      key.downcase.start_with?(style_lower)
    end

    unless prefix_matches.empty?
      # For prefix matches, return the shortest one
      best_match = prefix_matches.min_by(&:length)
      return best_match.to_sym
    end

    # Try character-by-character fuzzy matching for partial inputs
    # Find keys where the input characters appear in order (not necessarily contiguous)
    fuzzy_matches = indicator_keys.select do |key|
      key_chars = key.downcase.chars
      input_chars = style_lower.chars

      # Check if all input characters appear in order in the key
      input_chars.all? do |char|
        idx = key_chars.index(char)
        if idx
          key_chars = key_chars[idx + 1..-1] # Remove matched chars and continue
          true
        else
          false
        end
      end
    end

    unless fuzzy_matches.empty?
      # Sort by length (prefer shorter keys)
      best_match = fuzzy_matches.min_by(&:length)
      return best_match.to_sym
    end

    # Fallback to substring matching
    substring_matches = indicator_keys.select do |key|
      key.downcase.include?(style_lower)
    end

    unless substring_matches.empty?
      best_match = substring_matches.min_by(&:length)
      return best_match.to_sym
    end

    # Default fallback
    :dots
  end

  def parse_speed(speed)
    case speed.to_s.downcase
    when /^f/, '1', '2', '3'
      0.05
    when /^m/, '4', '5', '6', '7'
      0.1
    when /^s/, '8', '9', '10'
      0.2
    else
      speed.to_f > 0 ? (1.0 / speed.to_f) : 0.1
    end
  end
end

require_relative '../lib/ruby-progress/fill_cli'

PrgCLI.run
