#!/usr/bin/env ruby
# frozen_string_literal: true
# ripple - A simple Ruby script to create a text ripple effect in the terminal.

## From the command line, you can run:
# $ ruby ripple "Your Text Here" --speed fast --rainbow --direction bidirectional
## Run a command during the animation:
# $ ruby ripple "Your Text Here" --speed fast --rainbow --direction bidirectional --command "sleep 5"
# This will animate the text "Your Text Here" with the specified options, and run the command in the background.

# Can be loaded as a library
# require 'ripple'
# rippler = Ripple.new(ARGV.join(" "), { speed: options[:speed], format: options[:direction], rainbow: options[:rainbow] })
# rippler.hide_cursor
# while true do
#   rippler.advance
# end
# rippler.show_cursor

## OR

# Ripple.progress("IN PROGRESS", :fast) { sleep 5 }

COLORS = {
  "red" => "\e[31m",
  "green" => "\e[32m",
  "yellow" => "\e[33m",
  "blue" => "\e[34m",
  "magenta" => "\e[35m",
  "cyan" => "\e[36m",
  "white" => "\e[37m",
  "dark_red" => "\e[31;1m",
  "dark_green" => "\e[32;1m",
  "dark_yellow" => "\e[33;1m",
  "dark_blue" => "\e[34;1m",
  "dark_magenta" => "\e[35;1m",
  "dark_cyan" => "\e[36;1m",
  "dark_white" => "\e[37;1m",
  "light_red" => "\e[31;2m",
  "light_green" => "\e[32;2m",
  "light_yellow" => "\e[33;2m",
  "light_blue" => "\e[34;2m",
  "light_magenta" => "\e[35;2m",
  "light_cyan" => "\e[36;2m",
  "light_white" => "\e[37;2m",
  "reset" => "\e[0m",
}.freeze

INDICATORS = {
  arc: %w[â—œ â—  â— â—ž â—¡ â—Ÿ],
  arrow: %w[â† â†– â†‘ â†— â†’ â†˜ â†“ â†™],
  arrow_pulse: [
    "â–¹â–¹â–¹â–¹â–¹",
    "â–¸â–¹â–¹â–¹â–¹",
    "â–¹â–¸â–¹â–¹â–¹",
    "â–¹â–¹â–¸â–¹â–¹",
    "â–¹â–¹â–¹â–¸â–¹",
    "â–¹â–¹â–¹â–¹â–¸"
  ],
  balloon: %w[. o O Â° O o .],
  block_1: %w[â––â––â–– â–˜â––â–– â––â–˜â–– â––â––â–˜],
  block_2: %w[â–Œ â–€ â– â–„],
  bounce: [
    "[    ]",
    "[=   ]",
    "[==  ]",
    "[=== ]",
    "[====]"
        ],
  circle: %w[â—‹â—‹â—‹ â—â—‹â—‹ â—‹â—â—‹ â—‹â—‹â—],
  classic: ["|", "/", "â€”", "\\"],
  dots: %w[â ‹ â ™ â ¹ â ¸ â ¼ â ´ â ¦ â § â ‡ â ],
  dots_2: %w[â£¾ â£½ â£» â¢¿ â¡¿ â£Ÿ â£¯ â£·],
  dots_3: %w[â ‹ â ™ â š â ž â – â ¦ â ´ â ² â ³ â “],
  dots_4: %w[â „ â † â ‡ â ‹ â ™ â ¸ â ° â   â ° â ¸ â ™ â ‹ â ‡ â †],
  dots_5: %w[â ‹ â ™ â š â ’ â ‚ â ‚ â ’ â ² â ´ â ¦ â – â ’ â  â  â ’ â “ â ‹],
  dots_6: %w[â  â ‰ â ™ â š â ’ â ‚ â ‚ â ’ â ² â ´ â ¤ â „ â „ â ¤ â ´ â ² â ’ â ‚ â ‚ â ’ â š â ™ â ‰ â ],
  dots_7: %w[â ˆ â ‰ â ‹ â “ â ’ â  â  â ’ â – â ¦ â ¤ â   â   â ¤ â ¦ â – â ’ â  â  â ’ â “ â ‹ â ‰ â ˆ],
  dots_8: %w[â  â  â ‰ â ™ â š â ’ â ‚ â ‚ â ’ â ² â ´ â ¤ â „ â „ â ¤ â   â   â ¤ â ¦ â – â ’ â  â  â ’ â “ â ‹ â ‰ â ˆ â ˆ],
  dots_9: %w[â¢¹ â¢º â¢¼ â£¸ â£‡ â¡§ â¡— â¡],
  dots_10: %w[â¢„ â¢‚ â¢ â¡ â¡ˆ â¡ â¡ ],
  dots_11: %w[â  â ‚ â „ â¡€ â¢€ â   â  â ˆ],
  ellipsis: [".   ", "..  ", "... ", "...."],
  lighthouse: ["âˆ™âˆ™âˆ™", "â—âˆ™âˆ™", "âˆ™â—âˆ™", "âˆ™âˆ™â—"],
  o: %w[Ooo oOo ooO],
  pipe: %w[â”¤ â”˜ â”´ â”” â”œ â”Œ â”¬ â”],
  pulse: %w[âŽº âŽ» âŽ¼ âŽ½ âŽ¼ âŽ»],
  pulse_2: %w[â– â–ƒ â–… â–† â–‡ â–ˆ â–‡ â–† â–… â–ƒ],
  pulse_3: %w[â–‰ â–Š â–‹ â–Œ â– â–Ž â– â–Ž â– â–Œ â–‹ â–Š â–‰],
  pulse_4: %w[- = â‰¡ = -],
  push: [
    "[>    ]",
    "[=>   ]",
    "[==>  ]",
    "[===> ]",
    "[====>]"
        ],
  spin: %w[â—´ â—· â—¶ â—µ],
  spin_2: %w[â— â—“ â—‘ â—’],
  spin_3: %w[â—° â—³ â—² â—±],
  toggle: %w[â–  â–¡ â–ª â–«],
  triangle: %w[â—¢ â—£ â—¤ â—¥]
}

class ::String
  COLORS.each do |color_name, color_code|
    define_method(color_name) do
      "#{color_code}#{self}#{COLORS['reset']}"
    end
  end

  def rainbow(index = 0)
    chars = split('')
    colored_chars = chars.map.with_index do |char, idx|
      color = COLORS.values[(idx + index) % COLORS.size]
      "#{color}#{char}#{COLORS['reset']}"
    end
    colored_chars.join
  end

  def normalize_type
    spinner_type = :classic
    INDICATORS.each do |spinner, v|
      if spinner =~ /^#{self.split('').join('.*?')}/i
        spinner_type = spinner
      end
    end
    spinner_type
  end
end

class Ripple
  attr_accessor :index, :string, :speed, :format, :inverse, :rainbow, :spinner, :spinner_position, :caps

  def initialize(string, options = {})
    defaults = {
      speed: :medium,
      format: :bidirectional,
      rainbow: false,
      spinner: false,
      spinner_position: false,
      caps: false,
      inverse: false,
      output: :error
    }
    @options = defaults.merge(options)
    @string = string
    @index = 0
    @direction = :forward
    @rainbow = @options[:rainbow]
    @spinner = @options[:spinner]
    @spinner_position = @options[:spinner_position]
    @caps = @options[:caps]
    @inverse = @options[:inverse]
  end

  def printout
    letters = @string.dup.split('')
    i = @index
    if @spinner
      case @spinner_position
      when :before
        pre = "#{INDICATORS[@spinner][i]} "
        post = @string
      else
        pre = "#{@string} "
        post = INDICATORS[@spinner][i]
      end
    elsif @caps
      pre = letters.slice!(0,i).join
      char = letters.slice!(0,2).join
      post = letters.slice!(0,letters.length).join
      pre = @inverse ? pre.upcase : pre.downcase
      char = @inverse ? char.downcase : char.upcase
      post = @inverse ? post.upcase : post.downcase
    elsif @inverse
      pre = letters.slice!(0,i).join
      pre = @rainbow ? pre.rainbow : pre.light_white
      char = letters.slice!(0,2).join
      char = char.dark_white
      post = letters.slice!(0,letters.length).join
      post = @rainbow ? post.rainbow : post.light_white
    else
      pre = letters.slice!(0,i).join.dark_white
      char = letters.slice!(0,2).join
      char = @rainbow ? char.rainbow(i) : char.light_white
      post = letters.slice!(0,letters.length).join.dark_white
    end
    $stderr.print "\e[2K#{pre}#{char}#{post}\r"
  end

  # Hide or show the cursor
  def self.hide_cursor
    $stderr.print "\e[?25l"
  end

  def self.show_cursor
    $stderr.print "\e[?25h"
  end

  def self.complete(string, message, checkmark, success)
    mark = ""
    if checkmark && success
      mark = "âœ… "
    elsif checkmark
      mark = "ðŸ›‘ "
    end

    if message
      $stderr.puts "\e[2K#{mark}#{message}"
    elsif checkmark
      $stderr.puts "\e[2K#{mark}#{string}"
    end
  end

  def advance
    max = @spinner ? (INDICATORS[@spinner].count - 1) : (@string.length - 1)
    advance = true

    if @index == max && @options[:format] != :forward_only
      @direction = :backward
    elsif @index == max && @options[:format] == :forward_only
      @index = 0
      advance = false
    elsif @index == 0
      @direction = :forward
    end

    if advance
      @index = @direction == :backward ? @index - 1 : @index + 1
    end

    printout

    case @options[:speed]
    when :fast
      sleep 0.05
    when :medium
      sleep 0.1
    else
      sleep 0.2
    end
  end

  def self.progress(string, options = {})
    Signal.trap("INT") do
      Thread.current.kill
      nil
    end
    defaults = { speed: :medium,
                 format: :bidirectional,
                 rainbow: false,
                 inverse: false,
                 output: :error }
    options = defaults.merge(options)

    rippler = new(string, options)
    Ripple.hide_cursor
    begin
      thread = Thread.new do
        while true
          rippler.advance
        end
      end
      result = yield if block_given?
      thread.kill

      if @options[:output] == :error
        $?.exitstatus.zero?
      elsif @options[:output] == :stdout
        result
      else
        nil
      end
    rescue StandardError
      thread&.kill
      nil
    ensure
      Ripple.show_cursor
    end
  end
end

if __FILE__ == $PROGRAM_NAME

  require 'optparse'

  trap("INT") {
    Ripple.show_cursor
    exit
  }

  options = { speed: :medium,
              direction: :bidirectional,
              rainbow: false,
              spinner: false,
              spinner_position: :before,
              caps: false,
              inverse: false,
              command: nil,
              success_message: nil,
              fail_message: nil,
              complete_checkmark: false }

  OptionParser.new do |opts|
    opts.banner = "Usage: ripple [options] STRING"

    opts.on("-s", "--speed SPEED", [:fast, :medium, :slow], "Set animation speed ((f)ast/(m)edium/(s)low)") do |s|
      options[:speed] = case s
                        when /^f/ then :fast
                        when /^m/ then :medium
                        when /^s/ then :slow
                        else :slow
                        end
    end

    opts.on("-r", "--rainbow", "Enable rainbow mode") do
      options[:rainbow] = true
    end

    opts.on("-d", "--direction DIRECTION", "Set animation format ((f)orward/(b)ack-and-forth)") do |f|
      options[:format] = f =~ /^f/ ? :forward_only : :bidirectional
    end

    opts.on("-i", "--inverse", "Enable inverse mode") do
      options[:inverse] = true
    end

    opts.on("-c", "--command COMMAND", "Run a command during the animation") do |command|
      options[:command] = command
    end

    opts.on("--success MESSAGE", "Message to display on success") do |msg|
      options[:success_message] = msg
    end

    opts.on("--fail MESSAGE", "Message to display on error") do |msg|
      options[:fail_message] = msg
    end

    opts.on("--checkmark") do
      options[:complete_checkmark] = true
    end

    opts.on("--spinner TYPE", "Display a rippling spinner with the message") do |type|
      options[:spinner] = type.normalize_type
    end

    opts.on("--spinner-pos POSITION", "Display spinner [b]efore or [a]fter message") do |pos|
      options[:spinner_position] = pos =~ /^a/ ? :after : :before
    end

    opts.on("--list-spinners", "List available spinners") do
      out = "Spinners:\n"
      INDICATORS.each do |k, v|
        out += "- #{k}: #{v[2]}\n"
      end
      puts out
      exit
    end

    opts.on("--caps") do
      options[:caps] = true
    end

    opts.on("--stdout", "Output captured command result to STDOUT") do |output|
      options[:output] = :stdout
    end

    opts.on("--quiet", "Suppress all output") do |quiet|
      options[:output] = :quiet
    end

    opts.on("-v", "--version", "Display the version") do
      puts "Ripple version #{Ripple::VERSION || "1.0.0"}"
      exit
    end

    opts.on("-h", "--help", "Display this help message") do
      puts opts
      exit
    end
  end.parse!

  if ARGV.empty?
    puts "Please provide a string to animate as an argument."
    exit 1
  end

  if options[:command]
    captured_output = nil
    res = Ripple.progress(ARGV.join(" "), options) do
      captured_output = `#{options[:command]} 2>&1`
    end

    res = $?.success?

    if options[:output] == :stdout
      puts captured_output
    end
    if options[:success_message]
      message = res ? options[:success_message] : options[:fail_message] ? options[:fail_message] : options[:success_message]
      Ripple.complete(ARGV.join(" "), message, options[:complete_checkmark], res)
    end
    exit res ? 0 : 1
  end

  rippler = Ripple.new(ARGV.join(" "), { speed: options[:speed], format: options[:format], rainbow: options[:rainbow], inverse: options[:inverse] })
  Ripple.hide_cursor
  while true do
    rippler.advance
  end
  Ripple.show_cursor
  Ripple.complete(ARGV.join(" "), options[:success_message], options[:complete_checkmark], true)
end