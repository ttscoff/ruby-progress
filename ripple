#!/usr/bin/env ruby
# frozen_string_literal: true
# ripple - A simple Ruby script to create a text ripple effect in the terminal.

## From the command line, you can run:
# $ ruby ripple "Your Text Here" --speed fast --rainbow --direction bidirectional
## Run a command during the animation:
# $ ruby ripple "Your Text Here" --speed fast --rainbow --direction bidirectional --command "sleep 5"
# This will animate the text "Your Text Here" with the specified options, and run the command in the background.

# Can be loaded as a library
# require 'ripple'
# rippler = Ripple.new(ARGV.join(" "), { speed: options[:speed], format: options[:direction], rainbow: options[:rainbow] })
# rippler.hide_cursor
# while true do
#   rippler.advance
# end
# rippler.show_cursor

## OR

# Ripple.progress("IN PROGRESS", :fast) { sleep 5 }

COLORS = {
  "red" => "\e[31m",
  "green" => "\e[32m",
  "yellow" => "\e[33m",
  "blue" => "\e[34m",
  "magenta" => "\e[35m",
  "cyan" => "\e[36m",
  "white" => "\e[37m",
  "dark_red" => "\e[31;1m",
  "dark_green" => "\e[32;1m",
  "dark_yellow" => "\e[33;1m",
  "dark_blue" => "\e[34;1m",
  "dark_magenta" => "\e[35;1m",
  "dark_cyan" => "\e[36;1m",
  "dark_white" => "\e[37;1m",
  "light_red" => "\e[31;2m",
  "light_green" => "\e[32;2m",
  "light_yellow" => "\e[33;2m",
  "light_blue" => "\e[34;2m",
  "light_magenta" => "\e[35;2m",
  "light_cyan" => "\e[36;2m",
  "light_white" => "\e[37;2m",
  "reset" => "\e[0m",
}.freeze

INDICATORS = {
  arc: %w[‚óú ‚ó† ‚óù ‚óû ‚ó° ‚óü],
  arrow: %w[‚Üê ‚Üñ ‚Üë ‚Üó ‚Üí ‚Üò ‚Üì ‚Üô],
  arrow_pulse: [
    "‚ñπ‚ñπ‚ñπ‚ñπ‚ñπ",
    "‚ñ∏‚ñπ‚ñπ‚ñπ‚ñπ",
    "‚ñπ‚ñ∏‚ñπ‚ñπ‚ñπ",
    "‚ñπ‚ñπ‚ñ∏‚ñπ‚ñπ",
    "‚ñπ‚ñπ‚ñπ‚ñ∏‚ñπ",
    "‚ñπ‚ñπ‚ñπ‚ñπ‚ñ∏"
  ],
  balloon: %w[. o O ¬∞ O o .],
  block_1: %w[‚ññ‚ññ‚ññ ‚ñò‚ññ‚ññ ‚ññ‚ñò‚ññ ‚ññ‚ññ‚ñò],
  block_2: %w[‚ñå ‚ñÄ ‚ñê ‚ñÑ],
  bounce: [
    "[    ]",
    "[=   ]",
    "[==  ]",
    "[=== ]",
    "[====]"
        ],
  circle: %w[‚óã‚óã‚óã ‚óè‚óã‚óã ‚óã‚óè‚óã ‚óã‚óã‚óè],
  classic: ["|", "/", "‚Äî", "\\"],
  dots: %w[‚†ã ‚†ô ‚†π ‚†∏ ‚†º ‚†¥ ‚†¶ ‚†ß ‚†á ‚†è],
  dots_2: %w[‚£æ ‚£Ω ‚£ª ‚¢ø ‚°ø ‚£ü ‚£Ø ‚£∑],
  dots_3: %w[‚†ã ‚†ô ‚†ö ‚†û ‚†ñ ‚†¶ ‚†¥ ‚†≤ ‚†≥ ‚†ì],
  dots_4: %w[‚†Ñ ‚†Ü ‚†á ‚†ã ‚†ô ‚†∏ ‚†∞ ‚†† ‚†∞ ‚†∏ ‚†ô ‚†ã ‚†á ‚†Ü],
  dots_5: %w[‚†ã ‚†ô ‚†ö ‚†í ‚†Ç ‚†Ç ‚†í ‚†≤ ‚†¥ ‚†¶ ‚†ñ ‚†í ‚†ê ‚†ê ‚†í ‚†ì ‚†ã],
  dots_6: %w[‚†Å ‚†â ‚†ô ‚†ö ‚†í ‚†Ç ‚†Ç ‚†í ‚†≤ ‚†¥ ‚†§ ‚†Ñ ‚†Ñ ‚†§ ‚†¥ ‚†≤ ‚†í ‚†Ç ‚†Ç ‚†í ‚†ö ‚†ô ‚†â ‚†Å],
  dots_7: %w[‚†à ‚†â ‚†ã ‚†ì ‚†í ‚†ê ‚†ê ‚†í ‚†ñ ‚†¶ ‚†§ ‚†† ‚†† ‚†§ ‚†¶ ‚†ñ ‚†í ‚†ê ‚†ê ‚†í ‚†ì ‚†ã ‚†â ‚†à],
  dots_8: %w[‚†Å ‚†Å ‚†â ‚†ô ‚†ö ‚†í ‚†Ç ‚†Ç ‚†í ‚†≤ ‚†¥ ‚†§ ‚†Ñ ‚†Ñ ‚†§ ‚†† ‚†† ‚†§ ‚†¶ ‚†ñ ‚†í ‚†ê ‚†ê ‚†í ‚†ì ‚†ã ‚†â ‚†à ‚†à],
  dots_9: %w[‚¢π ‚¢∫ ‚¢º ‚£∏ ‚£á ‚°ß ‚°ó ‚°è],
  dots_10: %w[‚¢Ñ ‚¢Ç ‚¢Å ‚°Å ‚°à ‚°ê ‚°†],
  dots_11: %w[‚†Å ‚†Ç ‚†Ñ ‚°Ä ‚¢Ä ‚†† ‚†ê ‚†à],
  ellipsis: [".   ", "..  ", "... ", "...."],
  lighthouse: ["‚àô‚àô‚àô", "‚óè‚àô‚àô", "‚àô‚óè‚àô", "‚àô‚àô‚óè"],
  o: %w[Ooo oOo ooO],
  pipe: %w[‚î§ ‚îò ‚î¥ ‚îî ‚îú ‚îå ‚î¨ ‚îê],
  pulse: %w[‚é∫ ‚éª ‚éº ‚éΩ ‚éº ‚éª],
  pulse_2: %w[‚ñÅ ‚ñÉ ‚ñÖ ‚ñÜ ‚ñá ‚ñà ‚ñá ‚ñÜ ‚ñÖ ‚ñÉ],
  pulse_3: %w[‚ñâ ‚ñä ‚ñã ‚ñå ‚ñç ‚ñé ‚ñè ‚ñé ‚ñç ‚ñå ‚ñã ‚ñä ‚ñâ],
  pulse_4: %w[- = ‚â° = -],
  push: [
    "[>    ]",
    "[=>   ]",
    "[==>  ]",
    "[===> ]",
    "[====>]"
        ],
  spin: %w[‚ó¥ ‚ó∑ ‚ó∂ ‚óµ],
  spin_2: %w[‚óê ‚óì ‚óë ‚óí],
  spin_3: %w[‚ó∞ ‚ó≥ ‚ó≤ ‚ó±],
  toggle: %w[‚ñ† ‚ñ° ‚ñ™ ‚ñ´],
  triangle: %w[‚ó¢ ‚ó£ ‚ó§ ‚ó•]
}

class ::String
  COLORS.each do |color_name, color_code|
    define_method(color_name) do
      "#{color_code}#{self}#{COLORS['reset']}"
    end
  end

  def rainbow(index = 0)
    chars = split('')
    colored_chars = chars.map.with_index do |char, idx|
      color = COLORS.values[(idx + index) % COLORS.size]
      "#{color}#{char}#{COLORS['reset']}"
    end
    colored_chars.join
  end

  def normalize_type
    spinner_type = :classic
    INDICATORS.each do |spinner, v|
      if spinner =~ /^#{self.split('').join('.*?')}/i
        spinner_type = spinner
      end
    end
    spinner_type
  end
end

class Ripple
  attr_accessor :index, :string, :speed, :format, :inverse, :rainbow, :spinner, :spinner_position, :caps

  def initialize(string, options = {})
    defaults = {
      speed: :medium,
      format: :bidirectional,
      rainbow: false,
      spinner: false,
      spinner_position: false,
      caps: false,
      inverse: false,
      output: :error
    }
    @options = defaults.merge(options)
    @string = string
    @index = 0
    @direction = :forward
    @rainbow = @options[:rainbow]
    @spinner = @options[:spinner]
    @spinner_position = @options[:spinner_position]
    @caps = @options[:caps]
    @inverse = @options[:inverse]
  end

  def printout
    letters = @string.dup.split('')
    i = @index
    if @spinner
      case @spinner_position
      when :before
        pre = "#{INDICATORS[@spinner][i]} "
        post = @string
      else
        pre = "#{@string} "
        post = INDICATORS[@spinner][i]
      end
    elsif @caps
      pre = letters.slice!(0,i).join
      char = letters.slice!(0,2).join
      post = letters.slice!(0,letters.length).join
      pre = @inverse ? pre.upcase : pre.downcase
      char = @inverse ? char.downcase : char.upcase
      post = @inverse ? post.upcase : post.downcase
    elsif @inverse
      pre = letters.slice!(0,i).join
      pre = @rainbow ? pre.rainbow : pre.light_white
      char = letters.slice!(0,2).join
      char = char.dark_white
      post = letters.slice!(0,letters.length).join
      post = @rainbow ? post.rainbow : post.light_white
    else
      pre = letters.slice!(0,i).join.dark_white
      char = letters.slice!(0,2).join
      char = @rainbow ? char.rainbow(i) : char.light_white
      post = letters.slice!(0,letters.length).join.dark_white
    end
    $stderr.print "\e[2K#{pre}#{char}#{post}\r"
  end

  # Hide or show the cursor
  def self.hide_cursor
    $stderr.print "\e[?25l"
  end

  def self.show_cursor
    $stderr.print "\e[?25h"
  end

  def self.complete(string, message, checkmark, success)
    mark = ""
    if checkmark && success
      mark = "‚úÖ "
    elsif checkmark
      mark = "üõë "
    end

    if message
      $stderr.puts "\e[2K#{mark}#{message}"
    elsif checkmark
      $stderr.puts "\e[2K#{mark}#{string}"
    end
  end

  def advance
    max = @spinner ? (INDICATORS[@spinner].count - 1) : (@string.length - 1)
    advance = true

    if @index == max && @options[:format] != :forward_only
      @direction = :backward
    elsif @index == max && @options[:format] == :forward_only
      @index = 0
      advance = false
    elsif @index == 0
      @direction = :forward
    end

    if advance
      @index = @direction == :backward ? @index - 1 : @index + 1
    end

    printout

    case @options[:speed]
    when :fast
      sleep 0.05
    when :medium
      sleep 0.1
    else
      sleep 0.2
    end
  end

  def self.progress(string, options = {})
    Signal.trap("INT") do
      Thread.current.kill
      nil
    end
    defaults = { speed: :medium,
                 format: :bidirectional,
                 rainbow: false,
                 inverse: false,
                 output: :error }
    options = defaults.merge(options)

    rippler = new(string, options)
    Ripple.hide_cursor
    begin
      thread = Thread.new do
        while true
          rippler.advance
        end
      end
      result = yield if block_given?
      thread.kill

      if @options[:output] == :error
        $?.exitstatus.zero?
      elsif @options[:output] == :stdout
        result
      else
        nil
      end
    rescue StandardError
      thread&.kill
      nil
    ensure
      Ripple.show_cursor
    end
  end
end

if __FILE__ == $PROGRAM_NAME

  require 'optparse'

  trap("INT") {
    Ripple.show_cursor
    exit
  }

  options = { speed: :medium,
              direction: :bidirectional,
              rainbow: false,
              spinner: false,
              spinner_position: :before,
              caps: false,
              inverse: false,
              command: nil,
              success_message: nil,
              fail_message: nil,
              complete_checkmark: false }

  OptionParser.new do |opts|
    opts.banner = "Usage: ripple [options] STRING"

    opts.on("-s", "--speed SPEED", [:fast, :medium, :slow], "Set animation speed ((f)ast/(m)edium/(s)low)") do |s|
      options[:speed] = case s
                        when /^f/ then :fast
                        when /^m/ then :medium
                        when /^s/ then :slow
                        else :slow
                        end
    end

    opts.on("-r", "--rainbow", "Enable rainbow mode") do
      options[:rainbow] = true
    end

    opts.on("-d", "--direction DIRECTION", "Set animation format ((f)orward/(b)ack-and-forth)") do |f|
      options[:format] = f =~ /^f/ ? :forward_only : :bidirectional
    end

    opts.on("-i", "--inverse", "Enable inverse mode") do
      options[:inverse] = true
    end

    opts.on("-c", "--command COMMAND", "Run a command during the animation") do |command|
      options[:command] = command
    end

    opts.on("--success MESSAGE", "Message to display on success") do |msg|
      options[:success_message] = msg
    end

    opts.on("--fail MESSAGE", "Message to display on error") do |msg|
      options[:fail_message] = msg
    end

    opts.on("--checkmark") do
      options[:complete_checkmark] = true
    end

    opts.on("--spinner TYPE", "Display a rippling spinner with the message") do |type|
      options[:spinner] = type.normalize_type
    end

    opts.on("--spinner-pos POSITION", "Display spinner [b]efore or [a]fter message") do |pos|
      options[:spinner_position] = pos =~ /^a/ ? :after : :before
    end

    opts.on("--list-spinners", "List available spinners") do
      out = "Spinners:\n"
      INDICATORS.each do |k, v|
        out += "- #{k}: #{v[2]}\n"
      end
      puts out
      exit
    end

    opts.on("--caps") do
      options[:caps] = true
    end

    opts.on("--stdout", "Output captured command result to STDOUT") do |output|
      options[:output] = :stdout
    end

    opts.on("--quiet", "Suppress all output") do |quiet|
      options[:output] = :quiet
    end

    opts.on("-v", "--version", "Display the version") do
      puts "Ripple version #{Ripple::VERSION || "1.0.0"}"
      exit
    end

    opts.on("-h", "--help", "Display this help message") do
      puts opts
      exit
    end
  end.parse!

  if ARGV.empty?
    puts "Please provide a string to animate as an argument."
    exit 1
  end

  if options[:command]
    captured_output = nil
    res = Ripple.progress(ARGV.join(" "), options) do
      captured_output = `#{options[:command]} 2>&1`
    end

    res = $?.success?

    if options[:output] == :stdout
      puts captured_output
    end
    if options[:success_message]
      message = res ? options[:success_message] : options[:fail_message] ? options[:fail_message] : options[:success_message]
      Ripple.complete(ARGV.join(" "), message, options[:complete_checkmark], res)
    end
    exit res ? 0 : 1
  end

  rippler = Ripple.new(ARGV.join(" "), { speed: options[:speed], format: options[:format], rainbow: options[:rainbow], inverse: options[:inverse] })
  Ripple.hide_cursor
  while true do
    rippler.advance
  end
  Ripple.show_cursor
  Ripple.complete(ARGV.join(" "), options[:success_message], options[:complete_checkmark], true)
end